---
title: "Repository Management with git"
description: "Review of fundamental git techniques. Also, lecture notes on emphasising git theory/best practises especially relevant for open source project development."
sidebar:
  hidden: false
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

## What is Git?

*These notes were adapted from https://microsoft.github.io/code-with-engineering-playbook/source-control/git-guidance/*

Git is a **distributed version control system**. Every participant has a local copy of the source-code, and the attached history that is kept in sync by comparing commit **hashes** ([SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) hashes of changes between each git commit command) making up the latest version (called `HEAD`).

```bash
repo 1: A -> B -> C -> D -> HEAD
repo 2: A -> B -> HEAD
repo 3: X -> Y -> Z -> HEAD
repo 4: A -> J -> HEAD
```

Since they share a common history, repo 1 and repo 2 can be synchronized
fairly easily, repo 4 *may* be able to synchronize as well, but it\'s
going to have to add a commit (J, and maybe a merge commit) to repo 1.
Repo 3 cannot be easily synchronized with the others. Everything related
to these commits is stored in a local .git directory in the root of the
repository.

In other words, **by using Git you are simply creating immutable file
histories that uniquely identify the current state and therefore allow
sharing whatever comes after**.

## Basic workflow

A basic Git workflow is as follows. 

```bash
# pull the latest changes
git pull

# start a new feature branch based on the "develop" branch
git checkout -b feature/123-add-git-instructions develop

# another way to do the same thing:
git switch -c feature/123-add-git-instructions develop

# edit some files

# add and commit the files
git add <file>
git commit -m "add basic instructions"

# edit some files

# add and commit the files
git add <file>
git commit

# "git commit" will cause your $EDITOR will appear -- this is an environment variable that can be changed. Common CLI options are `nano`, `vim`, and `emacs`. In a git GUI, a built-in editor will appear at this point.
# This allows you to write multi-line commit messages, which is important for large changes.

# check your changes
# 'git status' may be the git command I use most
git status

# by default, `git diff` shows the line-by-line additions/removals/changes to all unstaged changes in your repository
git diff

# push the branch to the remote repository (i.e. -- add the branch to the remote repo)
git push --set-upstream origin feature/123-add-git-instructions
```




While what is shown above are CLI commands, **you can replicate any CLI command using a Git GUI of your choice** -- all Git GUIs will have these commands available to them. [Android Studio has built-in git Version Control](https://developer.android.com/studio/projects/version-control), and [GitHub Desktop](https://desktop.github.com/) is a recommended GUI for working with GitHub as well.

An additional Android Studio Git recommendation: [this link starting from step 4 is very useful](https://code.tutsplus.com/working-with-git-in-android-studio--cms-30514t)

An additional GitHub Desktop recommendation: [this link is very useful](https://docs.github.com/en/desktop/making-changes-in-a-branch/pushing-changes-to-github-from-github-desktop)


### Cloning

Whenever you want to make a change to a repository, you need to first
clone it. Cloning a repository pulls down a full copy of all the
repository data, so that you can work on it locally. This copy includes
all versions of every file and folder for the project.

```bash
git clone https://github.com/username/repo-name
```

You only need to clone the repository the first time. Before any
subsequent branches you can sync any changes from the remote repository
using `git pull`.

### Branching

To avoid adding code that has not been peer reviewed to the main branch
(ex. `develop`) we typically work in feature branches, and merge these
back to the main trunk with a Pull Request. It\'s even the case that
often the `main` or `develop` branch of a repository are locked so that
you can\'t make changes without a Pull Request. Therefore, it is useful
to create a separate branch for your local/feature work, so that you can
work and track your changes in this branch.

Pull the latest changes and create a new branch for your work based on
the trunk (in this case `develop`).

```bash
git pull

# checkout is used for commits, -b is a branch flag
git checkout -b feature/feature-name develop

# an alternative that does the same thing, "-c" to create the branch:
git switch -c feature/feature-name develop
```

At any point, you can move between the branches with
`git checkout <branch>` or `git switch <branch>` as long as you have committed or stashed your
work. If you forget the name of your branch use `git branch --all` to
list all branches.

### Committing

To avoid losing work, it is good to **commit often in small chunks**. This
allows you to revert only the last changes if you discover a problem and
also neatly explains exactly what changes were made and why.

1.  Make changes to your branch

2.  Check what files were changed

    ```bash
    > git status
    On branch feature/271-basic-commit-info
    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git restore <file>..." to discard changes in working directory)
            modified:   source-control/git-guidance/README.md
    ```

3.  Track the files you wish to include in the commit. To track all
    modified files:

    ```bash
    git add --all
    ```

    Or to track only specific files:

    ```bash
    git add source-control/git-guidance/README.md
    ```

4.  Commit the changes to your local branch with a descriptive [commit
    message](#commit-best-practices)

    ```bash
    git commit -m "add basic git instructions"
    ```

### Pushing

When you are done working, push your changes to a branch in the remote
repository using:

```bash
git push
```

The first time you push, you first need to set an upstream branch as
follows. After the first push, the `--set-upstream` parameter and branch
name are not needed anymore.

```bash
git push --set-upstream origin feature/feature-name
```

Once the feature branch is pushed to the remote repository, it is
visible to anyone with access to the code.

### Merging

In our project milestone, direct pushes to `main` are prohibited -- this means that we will need to request a `pull` from main branch instead, merging the feature you develop with the main codebase once it is approved. This makes sure that all code in the final product is [code
reviewed](https://microsoft.github.io/code-with-engineering-playbook/code-reviews/).

See [Pull Requests in GitHub](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) for clarifications about how to create a pull request.

:::tip
Why make **pull requests** instead of **pushes** to a shared repository? Once the repository is shared with more than once person, the code in it no longer belongs to a single developer. It is easy to accidentally push to a branch you own -- when it is your own branch, that is no problem, but when the branch is shared, that can introduce bugs and overwrite the work of colleagues.
:::

### Conflicts

If multiple people make changes to the same files, you may need to
resolve any conflicts that have occurred before you can merge.

```bash
# check out the develop branch and get the latest changes
git checkout develop
git pull

# check out your branch
git checkout <your branch>

# merge the develop branch into your branch
git merge develop

# if merge conflicts occur, above command will fail with a message telling you that there are conflicts to be solved

# find which files need to be resolved, and edit them to resolve the conflict
git status
```

Git conflicts produce a "diff", which can be resolved by selecting which parts of the conflict you want to accept or reject:

-   Accept your changes (current)
-   Accept the changes from dev branch (incoming)
-   Accept them both and fix the code (probably needed)

```bash
Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed.
<<<<<<< yours:sample.txt
Conflict resolution is hard;
let's go shopping.
=======
Git makes conflict resolution easy.
>>>>>>> theirs:sample.txt
And here is another line that is cleanly resolved or unmodified
```

When this process is completed, make sure you test the result by
executing build, checks, test to validate this merged result.

```bash
# conclude the merge
git merge --continue

# verify that everything went ok
git log

# push the changes to the remote branch
git push
```

If no other conflicts appear, the PR can now be merged, and your branch
deleted. **Use `squash` to reduce your changes into a single commit, so
the commit history can be within an acceptable size.**

### Rebasing

*The following notes were adapted from the MAN page of `git-rebase`.*

In my mind, `git rebase` is the more useful cousin of `git merge`.

`git-rebase`: Reapply commits from one branch on top of another branch. A short example follows.

Assume you have a branch `topic` that you have been working on. In the time since you began work, other developers have completed pull requests to `main` branch, and so your `topic` branch has fallen behind.

You can apply the following command (either one, same result):

```bash
git rebase main
git rebase main topic
```

And see the following change to your branches (click the tabs):

<Tabs>
  <TabItem label="Branches before rebase">

  ```bash
       a---b---c topic
      /
  d---e---f---g main
  ```

  </TabItem>
  <TabItem label="Branches after rebase">

  ```bash
               a*---b*---c* topic
              /
  d---e---f---g main
  ```

  </TabItem>
</Tabs>

A range of commits can also be removed with rebase. If we have the following situation:

```bash
E---F---G---H---I---J  topicA
```
then the command `git rebase --onto topicA~5 topicA~3 topicA` would result in the removal of commits F and G:

```bash
E---H*---I*---J*  topicA
```

This is useful if F and G were flawed in some way, or should not be
part of topicA. Note that the argument to `--onto` and the `<upstream>`
parameter can be any valid commit.

In case of conflict, git rebase will stop at the first problematic commit and leave conflict markers in the tree. You can use git diff to locate the markers `<<<<<<` and make edits to resolve the conflict. 

For each file you edit, you need to tell git that the conflict has been resolved, typically this would be done with `git add <filename>`

After resolving the conflict manually and updating the index with the desired resolution, you can continue the rebasing process with `git rebase --continue`

Alternatively, you can undo the git rebase with `git rebase --abort`

### Stashing changes

`git stash` is super handy if you have un-committed changes in your
working directory, but you want to work on a different branch. You can
run `git stash`, save the un-committed work, and revert to the HEAD
commit. You can retrieve the saved changes by running `git stash pop`:

```bash
git stash
…
git stash pop
```

Or you can move the current state into a new branch:

```bash
git stash branch <new_branch_to_save_changes>
```

### Recovering lost commits

If you \"lost\" a commit that you want to return to, for example to
revert a `git rebase` where your commits got squashed, you can use
`git reflog` to find the commit:

```bash
git reflog
```

Then you can use the reflog reference (`HEAD@{}`) to reset to a specific
commit before the rebase:

```bash
git reset HEAD@{2}
```

## Commit Best Practices

A commit combines changes into a logical unit. Adding a descriptive
commit message can aid in comprehending the code changes and
understanding the rationale behind the modifications. Consider the
following when making your commits:

One of the is distinguishing between **content** and **style** changes. You should adhere to the following rules:
  - Commits that change code style DO NOT change code behavior
  - Commits that change code behavior DO NOT change code style
  - Commits that refactor code DO NOT change code behavior

Your commits in general (even on development branches) should be **atomic**, that is:

> An **atomic commit** is a commit that includes changes related to only one feature or task of your program. There are two main reasons for doing this: first, if something you change turns out to cause some problems, it is easy to revert the specific change without losing other changes; and second, it enables you to write better commit messages. ([The Odin Project](https://www.theodinproject.com/lessons/foundations-git-basics))

Follow these steps to build the habit around generating atomic commits:

- Make small commits. This makes changes easier to review, and if we need to revert a commit, we lose less work. Consider splitting the commit into separate commits with `git add -p` if it includes more than one logical change or bug fix.
-   **Don't mix nonfunctional changes with functional code changes**. E.g., do not include whitespace changes or formatting refactors like that with code that changes the behavior of the application. This will make it easy to determine if a given commit has a functional change or only removes a whitespace, keeping your history coherent.
-   **Commit complete and well tested code. Never commit incomplete code,
    get in the habit of testing your code before committing.**
-   Write good commit messages.
    -   Why is it necessary? It may fix a bug, add a feature, improve
        performance, or just be a change for the sake of correctness
    -   What effects does this change have? In addition to the obvious
        ones, this may include benchmarks, side effects etc.

You can specify the default git editor, which allows you to write your
commit messages using your favorite editor. The following command makes
Visual Studio Code your default git editor:

```bash
git config --global core.editor "code --wait"
```

### Commit Message Structure

The essential parts of a commit message are: \* subject line: a short
description of the commit, maximum 50 characters long \* body
(optional): a longer description of the commit, wrapped at 72
characters, separated from the subject line by a blank line

You are free to structure commit messages; however, git commands like
`git log` utilize above structure. Therefore, it can be helpful to
follow a convention within your team and to utilize git best.

For example, [Conventional
Commits](https://www.conventionalcommits.org/) is a lightweight
convention that complements [SemVer](https://semver.org/), by describing
the features, fixes, and breaking changes made in commit messages. See
[Component Versioning](../component-versioning/) for more information on
versioning.

For more information on commit message conventions, see:

-   [A Note About Git Commit
    Messages](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)
-   [Conventional Commits](https://www.conventionalcommits.org)
-   [Git commit best
    practices](https://medium.com/@nawarpianist/git-commit-best-practices-dab8d722de99)
-   [How to Write a Git Commit Message](https://cbea.ms/git-commit)
-   [How to Write Better Git Commit
    Messages](https://www.freecodecamp.org/news/how-to-write-better-git-commit-messages)
-   [Information in commit
    messages](https://wiki.openstack.org/wiki/GitCommitMessages#Information_in_commit_messages)
-   [On commit
    messages](http://who-t.blogspot.com/2009/12/on-commit-messages.html)


## Managing remotes

A local git repository can have one or more backing remote repositories.
You can list the remote repositories using `git remote` - by default,
the remote repository you cloned from will be called origin

```bash
    > git remote -v
    origin  https://github.com/microsoft/code-with-engineering-playbook.git (fetch)
    origin  https://github.com/microsoft/code-with-engineering-playbook.git (push)
```

### Working with forks

You can set multiple remotes. This is useful for example if you want to
work with a forked version of the repository. For more info on how to
set upstream remotes and syncing repositories when working with forks
see GitHub\'s [Working with forks
documentation](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/working-with-forks).

### Updating the remote if a repository changes names

If the repository is changed in some way, for example a name change, or
if you want to switch between HTTPS and SSH you need to update the
remote

```bash
    # list the existing remotes
    > git remote -v
    origin  https://hostname/username/repository-name.git (fetch)
    origin  https://hostname/username/repository-name.git (push)

    # change the remote url
    git remote set-url origin https://hostname/username/new-repository-name.git

    # verify that the remote URL has changed
    > git remote -v
    origin  https://hostname/username/new-repository-name.git (fetch)
    origin  https://hostname/username/new-repository-name.git (push)
```

## Very useful git techniques

When sharing code with others, it is often required to organize the developer history mores stringently than when working alone. Each git commit is a snapshot of the codebase, and it is important that each snapshot is sensible and recoverable.

Before commits are pushed to a shared repository, they can be modified directly. This is a very useful tool for preparing a pull request: we can erase the commits that we have made previously and "request to pull" a brand new set of commits where necessary.

Whenever you have a code review that requests you fix things like commit messages/titles, or requests that you split an existing commit into smaller chunks, you will **need to reset or rebase those commits, recover the changes, and create new commits**. This is not so difficult, once you are used to it -- the two main commands you will need are `git rebase --interactive`, `git add --patch`, and `git reset --soft`. See below for more details.

### Workflow for interactive git rebase

*The following notes were adapted from the MAN page of `git-rebase`.*

Rebasing interactively means that you have a chance to edit the commits which are rebased. You can reorder the commits, you can change them, and you can remove them.

The interactive mode is meant for this type of workflow:

1. make a series of changes on a codebase, something like:
    <ol type="a">
      <li>create a series of completed commits</li>
      <li>make partial progress on some other work saved in a temporary commit</li>
      <li>fixup of some previous mistakes in the codebase</li>
    </ol>
2. commit those changes and `git push` them to a shared repository
3. your changes were not approved, repeat step 1 until they pass approval.

Sometimes the thing fixed in 1.c cannot be amended to the not-quite perfect commit it fixes, because that commit is buried deeply in your commit history. That is *exactly* what interactive rebase is for: use it after plenty of "1.a"s and "1.b"s, by rearranging and editing commits, and squashing multiple commits into one.

That is, after any normal day of development, `git rebase --interactive` lets you organize your work into a series of commits at will.

Start `git rebase -i` with the last commit you want to retain as-is:

```bash
git rebase -i SHA-or-reference-to-commit

## E.g. using reference to HEAD
git rebase -i HEAD~2

## E.g. SHA commit id (first 7 digits is enough)
git rebase -i fa1afe1
```

An editor will be fired up with all the commits in your current branch that come after the given commit. You can reorder the commits in this list to your heart’s content, and you can remove them. 

Assume the commit BEFORE the one you selected has the id `9f36727`. The resulting `git rebase` TODO list will look more or less like this:

```bash
pick deadbee The oneline of this commit
pick fa1afe1 The oneline of the next commit

# Rebase 9f36727..fa1afe1 onto 9f36727 (2 commands)
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit
# e, edit <commit> = use commit
# s, squash <commit> = use commit
# ... more commands follow 
```

The oneline descriptions are purely for your pleasure; `git rebase` will not look at them. The commit SHA-ids (`deadbee` and `fa1afe1` in this example) are the important part: do not delete or edit the ids.

The TODO list that `git rebase --interactive` is showing you is the **default commands that take place when you run a normal `git rebase`**. By default, each commit in the range specified is `picked` i.e. **applied** to your current branch, starting from the top and working towards the bottom.

What `git rebase --interactive` allows you to do is to *change* the `pick` instruction for each commit to **some other instruction**. This is where the real power of the command lies.

By replacing the command `pick` with the command `edit`, you can tell `git rebase` to stop after applying that commit, so that you can edit the files and/or the commit message, amend the commit, and continue rebasing.

To interrupt the rebase (just like an `edit` command would do, but without cherry-picking any commit first), use the `break` command.

If you just want to edit the commit message for a commit, replace the
command `pick` with the command `reword`.

To drop a commit, replace the command `pick` with `drop`, or just
delete the matching line.

If you want to fold two or more commits into one, replace the command
`pick` for the second and subsequent commits with `squash` or `fixup`.

`git rebase` **will stop to give you the change to make changes** when `pick` has been replaced with `edit` or when a command fails due to merge errors. When you are done editing and/or resolving conflicts you can continue with `git rebase --continue`.

Reordering and editing commits usually creates untested intermediate steps. You may want to check that your history editing did not break anything by running a test, or at least recompiling at intermediate points in history by using the `exec` command (shortcut "x"). You may do so by creating a todo list like this one:

```bash
pick deadbee Implement feature XXX
fixup f1a5c00 Fix to feature XXX
exec ./gradlew build # exec can run any shell command -- might as well rebuild the project!
pick c0ffeee The oneline of the next commit
edit deadbab The oneline of the commit after
exec ./gradlew build
...
```

The interactive rebase will stop when a command fails (i.e. exits with
non-0 status) to give you an opportunity to fix the problem. You can
continue with `git rebase --continue`.

The `exec` command launches the command in a shell (the one specified
in `$SHELL` or the default shell if `$SHELL` is not set), so you can use
shell features (like `cd`, `>`, `;` ...). The command is run from the
root of the working tree.

### Splitting commits in interactive git rebase

In interactive mode, you can mark commits with the action `edit`.
However, this does not necessarily mean that git rebase expects the
result of this edit to be exactly one commit. Indeed, you can undo the
commit, or you can add other commits. This can be used to split a
commit into two:

-   Start an interactive rebase with `git rebase -i <commit>`, where
`<commit>` is the commit you want to split. In fact, any commit range
will do, as long as it contains that commit.

-   Mark the commit you want to split with the action `edit`.

-   When it comes to editing that commit, execute git reset HEAD^. The
effect is that the HEAD is rewound by one, and the index follows
suit. However, the working tree stays the same.

-   Now add the changes to the index that you want to have in the first
commit. You can use git add (possibly interactively) or git gui (or
both) to do that.

-   Commit the now-current index with whatever commit message is
appropriate now.

-   Repeat the last two steps until your working tree is clean.

-   Continue the rebase with `git rebase --continue`.

If you are not absolutely sure that the intermediate revisions are
consistent (they compile, pass the testsuite, etc.) you should use git
stash to stash away the not-yet-committed changes after each commit,
test, and amend the commit if fixes are necessary.




### `git add --patch`

### `git reset --soft`

### Updating pull requests with --force

### `git pull --force`
