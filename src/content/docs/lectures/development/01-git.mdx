---
title: "Repository Management with git"
description: "Review of fundamental git techniques. Also, lecture notes on emphasising git theory/best practises especially relevant for open source project development."
sidebar:
  hidden: false
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

## What is Git?

*These notes were adapted from https://microsoft.github.io/code-with-engineering-playbook/source-control/git-guidance/*

Git is a **distributed version control system**. Every participant has a local copy of the source-code, and the attached history that is kept in sync by comparing commit **hashes** ([SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) hashes of changes between each git commit command) making up the latest version (called `HEAD`).

```bash
repo 1: A -> B -> C -> D -> HEAD
repo 2: A -> B -> HEAD
repo 3: X -> Y -> Z -> HEAD
repo 4: A -> J -> HEAD
```

Since they share a common history, repo 1 and repo 2 can be synchronized
fairly easily, repo 4 *may* be able to synchronize as well, but it\'s
going to have to add a commit (J, and maybe a merge commit) to repo 1.
Repo 3 cannot be easily synchronized with the others. Everything related
to these commits is stored in a local .git directory in the root of the
repository.

In other words, **by using Git you are simply creating immutable file
histories that uniquely identify the current state and therefore allow
sharing whatever comes after**.

## Basic workflow

A basic Git workflow is as follows. 

```bash
# pull the latest changes
git pull

# start a new feature branch based on the "develop" branch
git checkout -b feature/123-add-git-instructions develop

# another way to do the same thing:
git switch -c feature/123-add-git-instructions develop

# edit some files

# add and commit the files
git add <file>
git commit -m "add basic instructions"

# edit some files

# add and commit the files
git add <file>
git commit

# "git commit" will cause your $EDITOR will appear -- this is an environment variable that can be changed. Common CLI options are `nano`, `vim`, and `emacs`. In a git GUI, a built-in editor will appear at this point.
# This allows you to write multi-line commit messages, which is important for large changes.

# check your changes
# 'git status' may be the git command I use most
git status

# by default, `git diff` shows the line-by-line additions/removals/changes to all unstaged changes in your repository
git diff

# push the branch to the remote repository (i.e. -- add the branch to the remote repo)
git push --set-upstream origin feature/123-add-git-instructions
```




While what is shown above are CLI commands, **you can replicate any CLI command using a Git GUI of your choice** -- all Git GUIs will have these commands available to them. [Android Studio has built-in git Version Control](https://developer.android.com/studio/projects/version-control), and [GitHub Desktop](https://desktop.github.com/) is a recommended GUI for working with GitHub as well.

An additional Android Studio Git recommendation: [this link starting from step 4 is very useful](https://code.tutsplus.com/working-with-git-in-android-studio--cms-30514t)

An additional GitHub Desktop recommendation: [this link is very useful](https://docs.github.com/en/desktop/making-changes-in-a-branch/pushing-changes-to-github-from-github-desktop)


### Cloning

Whenever you want to make a change to a repository, you need to first
clone it. Cloning a repository pulls down a full copy of all the
repository data, so that you can work on it locally. This copy includes
all versions of every file and folder for the project.

```bash
git clone https://github.com/username/repo-name
```

You only need to clone the repository the first time. Before any
subsequent branches you can sync any changes from the remote repository
using `git pull`.

### Branching

To avoid adding code that has not been peer reviewed to the main branch
(ex. `develop`) we typically work in feature branches, and merge these
back to the main trunk with a Pull Request. It\'s even the case that
often the `main` or `develop` branch of a repository are locked so that
you can\'t make changes without a Pull Request. Therefore, it is useful
to create a separate branch for your local/feature work, so that you can
work and track your changes in this branch.

Pull the latest changes and create a new branch for your work based on
the trunk (in this case `develop`).

```bash
git pull

# checkout is used for commits, -b is a branch flag
git checkout -b feature/feature-name develop

# an alternative that does the same thing, "-c" to create the branch:
git switch -c feature/feature-name develop

# deleting a branch you don't need/created by mistake
git branch -d develop
```

At any point, you can move between the branches with
`git checkout <branch>` or `git switch <branch>` as long as you have committed or stashed your
work. If you forget the name of your branch use `git branch -a` to list all branches (see [Using remote branches](#using-remote-branches)).

### Committing

To avoid losing work, it is good to **commit often in small chunks**. This
allows you to revert only the last changes if you discover a problem and
also neatly explains exactly what changes were made and why.

1.  Make changes to your branch

2.  Check what files were changed

    ```bash
    > git status
    On branch feature/271-basic-commit-info
    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git restore <file>..." to discard changes in working directory)
            modified:   source-control/git-guidance/README.md
    ```

3.  Track the files you wish to include in the commit. To track all
    modified files:

    ```bash
    git add --all
    ```

    Or to track only specific files:

    ```bash
    git add source-control/git-guidance/README.md
    ```

4.  Commit the changes to your local branch with a descriptive [commit
    message](#commit-best-practices)

    ```bash
    git commit -m "add basic git instructions"
    ```

### Pushing

When you are done working, push your changes to a branch in the remote
repository using:

```bash
git push
```

The first time you push, you first need to set an upstream branch as
follows. After the first push, the `--set-upstream` parameter and branch
name are not needed anymore.

```bash
git push --set-upstream origin feature/feature-name
```

Once the feature branch is pushed to the remote repository, it is
visible to anyone with access to the code.

### Merging

In our project milestone, direct pushes to `main` are prohibited -- this means that we will need to request a `pull` from main branch instead, merging the feature you develop with the main codebase once it is approved. This makes sure that all code in the final product is [code
reviewed](https://microsoft.github.io/code-with-engineering-playbook/code-reviews/).

See [Pull Requests in GitHub](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) for clarifications about how to create a pull request.

:::tip
Why make **pull requests** instead of **pushes** to a shared repository? Once the repository is shared with more than once person, the code in it no longer belongs to a single developer. It is easy to accidentally push to a branch you own -- when it is your own branch, that is no problem, but when the branch is shared, that can introduce bugs and overwrite the work of colleagues.
:::

### Conflicts

If multiple people make changes to the same files, you may need to
resolve any conflicts that have occurred before you can merge.

```bash
# check out the develop branch and get the latest changes
git checkout develop
git pull

# check out your branch
git checkout <your branch>

# merge the develop branch into your branch
git merge develop

# if merge conflicts occur, above command will fail with a message telling you that there are conflicts to be solved

# find which files need to be resolved, and edit them to resolve the conflict
git status
```

Git conflicts produce a "diff", which can be resolved by selecting which parts of the conflict you want to accept or reject:

-   Accept your changes (current)
-   Accept the changes from dev branch (incoming)
-   Accept them both and fix the code (probably needed)

```diff ins={4-5} del={7} title="sample.txt"
Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed.
<<<<<<< ours:sample.txt           # git resolution marker
Conflict resolution is hard;       # changed in ours:sample.txt 
let's go shopping.                 # changes in ours:sample.txt
=======                            # git resolution divider
Git makes conflict resolution easy.    # changed in theirs:sample.txt
>>>>>>> theirs:sample.txt              # git resolution divider
And here is another line that is cleanly resolved or unmodified
```

You can use `git checkout --ours/theirs` to resolve these conflicts automatically:

<Tabs>
  <TabItem label="git checkout --ours">

After running `git checkout --ours`, `sample.txt` is automatically updated to only include the local changes:

```diff title="sample.txt" {3}
Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed.
Git makes conflict resolution easy.
And here is another line that is cleanly resolved or unmodified
```

  </TabItem>
  <TabItem label="git checkout --theirs">

After running `git checkout --theirs`, `sample.txt` is automatically updated to only include the remote changes:

```diff title="sample.txt" {3,4}
Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed.
Conflict resolution is hard;
let's go shopping.
And here is another line that is cleanly resolved or unmodified
```

  </TabItem>
  <TabItem label="Manual git resolution">

You can always manually resolve conflicts using your favourite editor. This way you can combine the two versions and modify them as you see fit:

```diff title="sample.txt" {3-4}
Here are lines that are either unchanged from the common
ancestor, or cleanly resolved because only one side changed.
Git makes conflict resolution easy.
Nevertheless, let's go shopping anyway.
And here is another line that is cleanly resolved or unmodified
```

  </TabItem>
</Tabs>

The merge process is completed when **all git conflict markers `<<<<` and `====` and `>>>>` are removed from the file**. Make sure you test the result by building your project before continuing.

```bash
# conclude the merge
git merge --continue

# verify that everything went ok
git log

# push the changes to the remote branch
git push
```

If no other conflicts appear, the PR can now be merged, and your branch
deleted. **Use `squash` to reduce your changes into a single commit, so
the commit history can be within an acceptable size.**

### Rebasing

*The following notes were adapted from the MAN page of `git-rebase`.*

In my mind, `git rebase` is the more useful cousin of `git merge`.

`git-rebase`: Reapply commits from one branch on top of another branch. A short example follows.

Assume you have a branch `topic` that you have been working on. In the time since you began work, other developers have completed pull requests to `main` branch, and so your `topic` branch has fallen behind.

You can apply the following command (either one, same result):

```bash
git rebase main
git rebase main topic
```

And see the following change to your branches (click the tabs):

<Tabs>
  <TabItem label="Branches before rebase">

  ```bash
       a---b---c topic
      /
  d---e---f---g main
  ```

  </TabItem>
  <TabItem label="Branches after rebase">

  ```bash
               a*---b*---c* topic
              /
  d---e---f---g main
  ```

  </TabItem>
</Tabs>

A range of commits can also be removed with rebase. If we have the following situation:

```bash
E---F---G---H---I---J  topicA
```
then the command `git rebase --onto topicA~5 topicA~3 topicA` would result in the removal of commits F and G:

```bash
E---H*---I*---J*  topicA
```

This is useful if F and G were flawed in some way, or should not be
part of topicA. Note that the argument to `--onto` and the `<upstream>`
parameter can be any valid commit.

In case of conflict, git rebase will stop at the first problematic commit and leave conflict markers in the tree. You can use git diff to locate the markers `<<<<<<` and make edits to resolve the conflict. 

For each file you edit, you need to tell git that the conflict has been resolved, typically this would be done with `git add <filename>`

After resolving the conflict manually and updating the index with the desired resolution, you can continue the rebasing process with `git rebase --continue`

Alternatively, you can undo the git rebase with `git rebase --abort`

### Stashing changes

`git stash` is super handy if you have un-committed changes in your
working directory, but you want to work on a different branch. You can
run `git stash`, save the un-committed work, and revert to the HEAD
commit. You can retrieve the saved changes by running `git stash pop`:

```bash
git stash
…
git stash pop
```

Or you can move the current state into a new branch:

```bash
git stash branch <new_branch_to_save_changes>
```

### Recovering lost commits

If you \"lost\" a commit that you want to return to, for example to
revert a `git rebase` where your commits got squashed, you can use
`git reflog` to find the commit:

```bash
git reflog
```

Then you can use the reflog reference (`HEAD@{}`) to reset to a specific
commit before the rebase:

```bash
git reset HEAD@{2}
```

## Commit Best Practices

*These notes are adapted from a [neat blogpost from GitHub with actual examples](https://github.blog/2022-06-30-write-better-commits-build-better-projects/) that you can follow along with*.

A commit combines changes into a logical unit. Adding a descriptive
commit message can aid in comprehending the code changes and
understanding the rationale behind the modifications. 

Commits should minimize the effort needed to build a mental model of the changes they introduce. With effort tied to having a “just right” amount of information, the key to a good commit is fitting into quantified upper and lower bounds on that information.

> A **small commit** is one with minimal scope; it does one “thing.” This often correlates to minimizing the modified lines of cone, but that isn’t a firm requirement. For example, changing the name of a commonly-used function may modify hundreds of lines of code, but its constrained scope makes it simple to both explain and review.

> A **commit is atomic** when it is a stable, independent unit of change. In concrete terms, a repository should still build, pass tests, and generally function if rolled back to that exact commit without needing other changes. In an atomic commit, your reader will have everything they need to evaluate the change in the commit itself.

Commits can be split and combined to adjust their size and scope -- tools for doing so are covered in later sections of this document.

### Commit Message Structure

The essential parts of a commit message are: 

- subject line: a short description of the commit, maximum 50 characters long
- body: Describe **what you’re doing** and **why** you’re doing it in the commit message.

Learn by example from famous open source developer [Tim Pope](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html):

```
Capitalized, short (50 chars or less) summary

More detailed explanatory text, if necessary.  Wrap it to about 72
characters or so.  In some contexts, the first line is treated as the
subject of an email and the rest of the text as the body.  The blank
line separating the summary from the body is critical (unless you omit
the body entirely); tools like rebase can get confused if you run the
two together.

Write your commit message in the imperative: "Fix bug" and not "Fixed bug"
or "Fixes bug."  This convention matches up with commit messages generated
by commands like git merge and git revert.

Further paragraphs come after blank lines.

- Bullet points are okay, too

- Typically a hyphen or asterisk is used for the bullet, followed by a
  single space, with blank lines in between, but conventions vary here

- Use a hanging indent
```

I personally like to do the following:

```
lowercase, (because it's nicer to look at) short summary

Explanation (similar to Tim's note above, treat it like an email with a quick context paragraph)

Requirements resolved:
- One bullet point per discrete requirement (i.e. defined in an Issue, you could link it here)

Changes made:
- Each discrete code change is a separate bullet
- You should be able to look at this commit message next to the commit diff and see each change represented in a bullet
```

You can see examples in action through in my [partially-solved Assignment 3 Pull Request](https://github.com/michaelhaaf/5A6-F23-assignment3/pull/2), in case you are having trouble visualising this.

More resources if you are interested: 

-   [A Note About Git Commit Messages](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)
-   [Conventional Commits](https://www.conventionalcommits.org)
-   [Git commit best practices](https://medium.com/@nawarpianist/git-commit-best-practices-dab8d722de99)
-   [How to Write a Git Commit Message](https://cbea.ms/git-commit)
-   [How to Write Better Git Commit Messages](https://www.freecodecamp.org/news/how-to-write-better-git-commit-messages)
-   [Information in commit messages](https://wiki.openstack.org/wiki/GitCommitMessages#Information_in_commit_messages)
-   [On commit messages](http://who-t.blogspot.com/2009/12/on-commit-messages.html)


## Managing remotes

A local git repository can have one or more backing remote repositories.
You can list the remote repositories using `git remote` - by default,
the remote repository you cloned from will be called origin

```bash
    > git remote -v
    origin  https://github.com/microsoft/code-with-engineering-playbook.git (fetch)
    origin  https://github.com/microsoft/code-with-engineering-playbook.git (push)
```

### Using remote branches

When you clone a repository with many branches (like my example [assignment 3 repository](https://github.com/michaelhaaf/5A6-F23-assignment3/)) it can appear like the only branch available is the default branch (here `main`):

```
$ git clone https://github.com/michaelhaaf/5A6-F23-assignment3/
$ cd 5A6-F23-assignment3
$ git status
On branch main
Your branch is up to date with 'origin/main'.

# use git branch to view repository branches
$ git branch
* main
```

Using `git branch` alone only lists the currently existing local branches. We can see view remote branches using the following parameters:

- `git branch -r` list **remote** branches
- `git branch -a` list **all** branches (local and remote)

```
$ git branch -a
* main  # the astertix indicates local branch we have checked out
  origin/HEAD -> origin/main
  origin/main
  origin/nav-codelab
  origin/state-codelab

$ git branch -r
  origin/HEAD -> origin/main
  origin/main
  origin/nav-codelab
  origin/state-codelab
```

You can create and "switch" to a local copy of any existing remote with `git switch`:

```
$ git switch state-codelab
branch 'state-codelab' set up to track 'origin/state-codelab'.
Switched to a new branch 'state-codelab'

$ git branch -a
  main
* state-codelab
  origin/HEAD -> origin/main
  origin/main
  origin/nav-codelab
  origin/state-codelab
```

### Working with forks

You can set multiple remotes. This is useful for example if you want to
work with a forked version of the repository. For more info on how to
set upstream remotes and syncing repositories when working with forks
see GitHub\'s [Working with forks
documentation](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/working-with-forks).

### Updating the remote if a repository changes names

If the repository is changed in some way, for example a name change, or
if you want to switch between HTTPS and SSH you need to update the
remote

```bash
    # list the existing remotes
    > git remote -v
    origin  https://hostname/username/repository-name.git (fetch)
    origin  https://hostname/username/repository-name.git (push)

    # change the remote url
    git remote set-url origin https://hostname/username/new-repository-name.git

    # verify that the remote URL has changed
    > git remote -v
    origin  https://hostname/username/new-repository-name.git (fetch)
    origin  https://hostname/username/new-repository-name.git (push)
```

## Very useful git techniques

When sharing code with others, it is often required to organize the developer history mores stringently than when working alone. Each git commit is a snapshot of the codebase, and it is important that each snapshot is sensible and recoverable.

Before commits are pushed to a shared repository, they can be modified directly. This is a very useful tool for preparing a pull request: we can erase the commits that we have made previously and "request to pull" a brand new set of commits where necessary.

Whenever you have a code review that requests you fix things like commit messages/titles, or requests that you split an existing commit into smaller chunks, you will **need to reset or rebase those commits, recover the changes, and create new commits**. This is not so difficult, once you are used to it -- the two main commands you will need are `git rebase --interactive`, `git add --patch`, and `git reset --soft`. See below for more details.

### Workflow for interactive git rebase

*The following notes were adapted from the MAN page of `git-rebase`.*

Rebasing interactively means that you have a chance to edit the commits which are rebased. You can reorder the commits, you can change them, and you can remove them.

The interactive mode is meant for this type of workflow:

1. make a series of changes on a codebase, something like:
    <ol type="a">
      <li>create a series of completed commits</li>
      <li>make partial progress on some other work saved in a temporary commit</li>
      <li>fixup of some previous mistakes in the codebase</li>
    </ol>
2. commit those changes and `git push` them to a shared repository
3. your changes were not approved, repeat step 1 until they pass approval.

Sometimes the thing fixed in 1.c cannot be amended to the not-quite perfect commit it fixes, because that commit is buried deeply in your commit history. That is *exactly* what interactive rebase is for: use it after plenty of "1.a"s and "1.b"s, by rearranging and editing commits, and squashing multiple commits into one.

That is, after any normal day of development, `git rebase --interactive` lets you organize your work into a series of commits at will.

Start `git rebase -i` with the last commit you want to retain as-is:

```bash
git rebase -i SHA-or-reference-to-commit

## E.g. using reference to HEAD
git rebase -i HEAD~2

## E.g. SHA commit id (first 7 digits is enough)
git rebase -i fa1afe1
```

An editor will be fired up with all the commits in your current branch that come after the given commit. You can reorder the commits in this list to your heart’s content, and you can remove them. 

Assume the commit BEFORE the one you selected has the id `9f36727`. The resulting `git rebase` TODO list will look more or less like this:

```bash
pick deadbee The oneline of this commit
pick fa1afe1 The oneline of the next commit

# Rebase 9f36727..fa1afe1 onto 9f36727 (2 commands)
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit
# e, edit <commit> = use commit
# s, squash <commit> = use commit
# ... more commands follow 
```

The oneline descriptions are purely for your pleasure; `git rebase` will not look at them. The commit SHA-ids (`deadbee` and `fa1afe1` in this example) are the important part: do not delete or edit the ids.

The TODO list that `git rebase --interactive` is showing you is the **default commands that take place when you run a normal `git rebase`**. By default, each commit in the range specified is `picked` i.e. **applied** to your current branch, starting from the top and working towards the bottom.

What `git rebase --interactive` allows you to do is to *change* the `pick` instruction for each commit to **some other instruction**. This is where the real power of the command lies.

By replacing the command `pick` with the command `edit`, you can tell `git rebase` to stop after applying that commit, so that you can edit the files and/or the commit message, amend the commit, and continue rebasing.

To interrupt the rebase (just like an `edit` command would do, but without cherry-picking any commit first), use the `break` command.

If you just want to edit the commit message for a commit, replace the
command `pick` with the command `reword`.

To drop a commit, replace the command `pick` with `drop`, or just
delete the matching line.

If you want to fold two or more commits into one, replace the command
`pick` for the second and subsequent commits with `squash` or `fixup`.

`git rebase` **will stop to give you the change to make changes** when `pick` has been replaced with `edit` or when a command fails due to merge errors. When you are done editing and/or resolving conflicts you can continue with `git rebase --continue`.

Reordering and editing commits usually creates untested intermediate steps. You may want to check that your history editing did not break anything by running a test, or at least recompiling at intermediate points in history by using the `exec` command (shortcut "x"). You may do so by creating a todo list like this one:

```bash
pick deadbee Implement feature XXX
fixup f1a5c00 Fix to feature XXX
exec ./gradlew build # exec can run any shell command -- might as well rebuild the project!
pick c0ffeee The oneline of the next commit
edit deadbab The oneline of the commit after
exec ./gradlew build
...
```

The interactive rebase will stop when a command fails (i.e. exits with
non-0 status) to give you an opportunity to fix the problem. You can
continue with `git rebase --continue`.

The `exec` command launches the command in a shell (the one specified
in `$SHELL` or the default shell if `$SHELL` is not set), so you can use
shell features (like `cd`, `>`, `;` ...). The command is run from the
root of the working tree.

### Splitting commits in interactive git rebase

In interactive mode, you can mark commits with the action `edit`.
However, this does not necessarily mean that git rebase expects the
result of this edit to be exactly one commit. Indeed, you can undo the
commit, or you can add other commits. This can be used to split a
commit into two:

-   Start an interactive rebase with `git rebase -i <commit>`, where
`<commit>` is the commit you want to split. In fact, any commit range
will do, as long as it contains that commit.

-   Mark the commit you want to split with the action `edit`.

-   When it comes to editing that commit, execute git reset HEAD^. The
effect is that the HEAD is rewound by one, and the index follows
suit. However, the working tree stays the same.

-   Now add the changes to the index that you want to have in the first
commit. You can use git add (possibly interactively) or git gui (or
both) to do that.

-   Commit the now-current index with whatever commit message is
appropriate now.

-   Repeat the last two steps until your working tree is clean.

-   Continue the rebase with `git rebase --continue`.

If you are not absolutely sure that the intermediate revisions are
consistent (they compile, pass the testsuite, etc.) you should use git
stash to stash away the not-yet-committed changes after each commit,
test, and amend the commit if fixes are necessary.




### `git add --patch`


<Tabs>
  <TabItem label="Rejecting a hunk">
   
```diff /.*Stage this hunk.*/
$ git add -p AdvancedStateAndSideEffectsCodelab/
diff --git a/AdvancedStateAndSideEffectsCodelab/app/build.gradle b/AdvancedStateAndSideEffectsCodelab/app/build.gradle
index 726de7a..47e44f7 100644
--- a/AdvancedStateAndSideEffectsCodelab/app/build.gradle
+++ b/AdvancedStateAndSideEffectsCodelab/app/build.gradle
@@ -42,16 +42,6 @@ android {
         manifestPlaceholders = [MAPS_API_KEY: properties.getProperty("MAPS_API_KEY", "")]
     }
 
-    signingConfigs {
-        // We use a bundled debug keystore, to allow debug builds from CI to be upgradable
-        debug {
-            storeFile rootProject.file('debug.keystore')
-            storePassword 'android'
-            keyAlias 'androiddebugkey'
-            keyPassword 'android'
-        }
-    }
-
     buildTypes {
         debug {
             signingConfig signingConfigs.debug
(1/2) Stage this hunk [y,n,q,a,d,j,J,g,/,e,?]? n
```

  </TabItem>
  <TabItem label="Accepting a hunk">

```diff /.*Stage this hunk.*/
@@ -126,6 +116,7 @@ dependencies {
     def lifecycle_version = "2.6.2"
     implementation "androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycle_version"
     implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"
+    implementation "androidx.lifecycle:lifecycle-runtime-compose:$lifecycle_version"
     implementation "com.google.dagger:hilt-android:2.48.1"
     kapt "com.google.dagger:hilt-compiler:2.48.1"
 
(2/2) Stage this hunk [y,n,q,a,d,K,g,/,e,?]? y
```

  </TabItem>
  <TabItem label="Editing a hunk">

```diff /.*Stage this hunk.*/
diff --git a/AdvancedStateAndSideEffectsCodelab/app/src/main/java/androidx/compose/samples/crane/home/CraneHome.kt b/AdvancedStateAndSideEffectsCodelab/app/src/main/java/androidx/compose/samples/crane/home/CraneHome.kt
index 5074428..4edde48 100644
--- a/AdvancedStateAndSideEffectsCodelab/app/src/main/java/androidx/compose/samples/crane/home/CraneHome.kt
+++ b/AdvancedStateAndSideEffectsCodelab/app/src/main/java/androidx/compose/samples/crane/home/CraneHome.kt
@@ -36,6 +36,7 @@ import androidx.compose.samples.crane.base.ExploreSection
 import androidx.compose.samples.crane.data.ExploreModel
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.graphics.Color
+import androidx.lifecycle.compose.collectAsStateWithLifecycle
 import androidx.lifecycle.viewmodel.compose.viewModel
 
 typealias OnExploreItemClicked = (ExploreModel) -> Unit
(1/2) Stage this hunk [y,n,q,a,d,j,J,g,/,e,?]? y
@@ -76,8 +77,8 @@ fun CraneHomeContent(
     modifier: Modifier = Modifier,
     viewModel: MainViewModel = viewModel(),
 ) {
-    // TODO Codelab: collectAsStateWithLifecycle step - consume stream of data from the ViewModel
-    val suggestedDestinations: List<ExploreModel> = remember { emptyList() }
+    val suggestedDestinations by viewModel.suggestedDestinations.collectAsStateWithLifecycle()
+
 
     val onPeopleChanged: (Int) -> Unit = { viewModel.updatePeople(it) }
     var tabSelected by remember { mutableStateOf(CraneScreen.Fly) }
(2/2) Stage this hunk [y,n,q,a,d,K,g,/,e,?]? y
```

  </TabItem>
  <TabItem label="Difference after patching">

```diff ins={7-8} del={13}
$ git status
On branch state-codelab
Your branch is up to date with 'origin/state-codelab'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   AdvancedStateAndSideEffectsCodelab/app/build.gradle
	modified:   AdvancedStateAndSideEffectsCodelab/app/src/main/java/androidx/compose/samples/crane/home/CraneHome.kt

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   AdvancedStateAndSideEffectsCodelab/app/build.gradle
```


  </TabItem>
</Tabs>




### `git reset --soft`

### `git commit --amend`

### Updating pull requests with --force

### `git pull --force`

