---
title: "Git and GitHub"
description: "Tips and tricks for maintaining clean repository history"
sidebar:
  hidden: false
---

## What is Git?

*These notes were adapted from https://microsoft.github.io/code-with-engineering-playbook/source-control/git-guidance/*

Git is a **distributed version control system**. Every participant has a local copy of the source-code, and the attached history that is kept in sync by comparing commit **hashes** ([SHA](https://en.wikipedia.org/wiki/Secure_Hash_Algorithm) hashes of changes between each git commit command) making up the latest version (called `HEAD`).

```bash
    repo 1: A -> B -> C -> D -> HEAD
    repo 2: A -> B -> HEAD
    repo 3: X -> Y -> Z -> HEAD
    repo 4: A -> J -> HEAD
```

Since they share a common history, repo 1 and repo 2 can be synchronized
fairly easily, repo 4 *may* be able to synchronize as well, but it\'s
going to have to add a commit (J, and maybe a merge commit) to repo 1.
Repo 3 cannot be easily synchronized with the others. Everything related
to these commits is stored in a local .git directory in the root of the
repository.

In other words, **by using Git you are simply creating immutable file
histories that uniquely identify the current state and therefore allow
sharing whatever comes after**.

## Basic workflow

A basic Git workflow is as follows. 

```bash
    # pull the latest changes
    git pull

    # start a new feature branch based on the "develop" branch
    git checkout -b feature/123-add-git-instructions develop

    # another way to do the same thing:
    git switch -c feature/123-add-git-instructions develop

    # edit some files

    # add and commit the files
    git add <file>
    git commit -m "add basic instructions"

    # edit some files

    # add and commit the files
    git add <file>
    git commit

    # "git commit" will cause your $EDITOR will appear -- this is an environment variable that can be changed. Common CLI options are `nano`, `vim`, and `emacs`. In a git GUI, a built-in editor will appear at this point.
    # This allows you to write multi-line commit messages, which is important for large changes.

    # check your changes
    # 'git status' may be the git command I use most
    git status

    # by default, `git diff` shows the line-by-line additions/removals/changes to all unstaged changes in your repository
    git diff

    # push the branch to the remote repository (i.e. -- add the branch to the remote repo)
    git push --set-upstream origin feature/123-add-git-instructions
```




While what is shown above are CLI commands, **you can replicate any CLI command using a Git GUI of your choice** -- all Git GUIs will have these commands available to them. [Android Studio has built-in git Version Control](https://developer.android.com/studio/projects/version-control), and [GitHub Desktop](https://desktop.github.com/) is a recommended GUI for working with GitHub as well.

An additional Android Studio Git recommendation: [this link starting from step 4 is very useful](https://code.tutsplus.com/working-with-git-in-android-studio--cms-30514t)

An additional GitHub Desktop recommendation: [this link is very useful](https://docs.github.com/en/desktop/making-changes-in-a-branch/pushing-changes-to-github-from-github-desktop)


### Cloning

Whenever you want to make a change to a repository, you need to first
clone it. Cloning a repository pulls down a full copy of all the
repository data, so that you can work on it locally. This copy includes
all versions of every file and folder for the project.

```bash
    git clone https://github.com/username/repo-name
```

You only need to clone the repository the first time. Before any
subsequent branches you can sync any changes from the remote repository
using `git pull`.

### Branching

To avoid adding code that has not been peer reviewed to the main branch
(ex. `develop`) we typically work in feature branches, and merge these
back to the main trunk with a Pull Request. It\'s even the case that
often the `main` or `develop` branch of a repository are locked so that
you can\'t make changes without a Pull Request. Therefore, it is useful
to create a separate branch for your local/feature work, so that you can
work and track your changes in this branch.

Pull the latest changes and create a new branch for your work based on
the trunk (in this case `develop`).

```bash
    git pull

    # checkout is used for commits, -b is a branch flag
    git checkout -b feature/feature-name develop

    # an alternative that does the same thing, "-c" to create the branch:
    git switch -c feature/feature-name develop
```

At any point, you can move between the branches with
`git checkout <branch>` or `git switch <branch>` as long as you have committed or stashed your
work. If you forget the name of your branch use `git branch --all` to
list all branches.

### Committing

To avoid losing work, it is good to **commit often in small chunks**. This
allows you to revert only the last changes if you discover a problem and
also neatly explains exactly what changes were made and why.

1.  Make changes to your branch

2.  Check what files were changed

    ```bash
        > git status
        On branch feature/271-basic-commit-info
        Changes not staged for commit:
          (use "git add <file>..." to update what will be committed)
          (use "git restore <file>..." to discard changes in working directory)
                modified:   source-control/git-guidance/README.md
    ```

3.  Track the files you wish to include in the commit. To track all
    modified files:

    ```bash
        git add --all
    ```

    Or to track only specific files:

    ```bash
        git add source-control/git-guidance/README.md
    ```

4.  Commit the changes to your local branch with a descriptive [commit
    message](#commit-best-practices)

    ```bash
        git commit -m "add basic git instructions"
    ```

### Pushing

When you are done working, push your changes to a branch in the remote
repository using:

```bash
    git push
```

The first time you push, you first need to set an upstream branch as
follows. After the first push, the `--set-upstream` parameter and branch
name are not needed anymore.

```bash
    git push --set-upstream origin feature/feature-name
```

Once the feature branch is pushed to the remote repository, it is
visible to anyone with access to the code.

### Merging

In our project milestone, direct pushes to `main` are prohibited -- this means that we will need to request a `pull` from main branch instead, merging the feature you develop with the main codebase once it is approved. This makes sure that all code in the final product is [code
reviewed](https://microsoft.github.io/code-with-engineering-playbook/code-reviews/).

See [Pull Requests in GitHub](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request) for clarifications about how to create a pull request.

:::tip
Why make **pull requests** instead of **pushes** to a shared repository? Once the repository is shared with more than once person, the code in it no longer belongs to a single developer. It is easy to accidentally push to a branch you own -- when it is your own branch, that is no problem, but when the branch is shared, that can introduce bugs and overwrite the work of colleagues.
:::

#### Merge Conflicts

If multiple people make changes to the same files, you may need to
resolve any conflicts that have occurred before you can merge.

```bash
    # check out the develop branch and get the latest changes
    git checkout develop
    git pull

    # check out your branch
    git checkout <your branch>

    # merge the develop branch into your branch
    git merge develop

    # if merge conflicts occur, above command will fail with a message telling you that there are conflicts to be solved

    # find which files need to be resolved, and edit them to resolve the conflict
    git status
```

Git conflicts produce a "diff", which can be resolved by selecting which parts of the conflict you want to accept or reject:

-   Accept your changes (current)
-   Accept the changes from dev branch (incoming)
-   Accept them both and fix the code (probably needed)

```bash
    Here are lines that are either unchanged from the common
    ancestor, or cleanly resolved because only one side changed.
    <<<<<<< yours:sample.txt
    Conflict resolution is hard;
    let's go shopping.
    =======
    Git makes conflict resolution easy.
    >>>>>>> theirs:sample.txt
    And here is another line that is cleanly resolved or unmodified
```

When this process is completed, make sure you test the result by
executing build, checks, test to validate this merged result.

```bash
    # conclude the merge
    git merge --continue

    # verify that everything went ok
    git log

    # push the changes to the remote branch
    git push
```

If no other conflicts appear, the PR can now be merged, and your branch
deleted. **Use `squash` to reduce your changes into a single commit, so
the commit history can be within an acceptable size.**

### Stashing changes

`git stash` is super handy if you have un-committed changes in your
working directory, but you want to work on a different branch. You can
run `git stash`, save the un-committed work, and revert to the HEAD
commit. You can retrieve the saved changes by running `git stash pop`:

```bash
    git stash
    â€¦
    git stash pop
```

Or you can move the current state into a new branch:

```bash
    git stash branch <new_branch_to_save_changes>
```

### Recovering lost commits

If you \"lost\" a commit that you want to return to, for example to
revert a `git rebase` where your commits got squashed, you can use
`git reflog` to find the commit:

```bash
    git reflog
```

Then you can use the reflog reference (`HEAD@{}`) to reset to a specific
commit before the rebase:

```bash
    git reset HEAD@{2}
```

## Commit Best Practices

A commit combines changes into a logical unit. Adding a descriptive
commit message can aid in comprehending the code changes and
understanding the rationale behind the modifications. Consider the
following when making your commits:

One of the is distinguishing between **content** and **style** changes. You should adhere to the following rules:
  - Commits that change code style DO NOT change code behavior
  - Commits that change code behavior DO NOT change code style
  - Commits that refactor code DO NOT change code behavior

Your commits in general (even on development branches) should be **atomic**, that is:

> An **atomic commit** is a commit that includes changes related to only one feature or task of your program. There are two main reasons for doing this: first, if something you change turns out to cause some problems, it is easy to revert the specific change without losing other changes; and second, it enables you to write better commit messages. ([The Odin Project](https://www.theodinproject.com/lessons/foundations-git-basics))

Follow these steps to build the habit around generating atomic commits:

- Make small commits. This makes changes easier to review, and if we need to revert a commit, we lose less work. Consider splitting the commit into separate commits with `git add -p` if it includes more than one logical change or bug fix.
-   **Don't mix nonfunctional changes with functional code changes**. E.g., do not include whitespace changes or formatting refactors like that with code that changes the behavior of the application. This will make it easy to determine if a given commit has a functional change or only removes a whitespace, keeping your history coherent.
-   **Commit complete and well tested code. Never commit incomplete code,
    get in the habit of testing your code before committing.**
-   Write good commit messages.
    -   Why is it necessary? It may fix a bug, add a feature, improve
        performance, or just be a change for the sake of correctness
    -   What effects does this change have? In addition to the obvious
        ones, this may include benchmarks, side effects etc.

You can specify the default git editor, which allows you to write your
commit messages using your favorite editor. The following command makes
Visual Studio Code your default git editor:

```bash
    git config --global core.editor "code --wait"
```

### Commit Message Structure

The essential parts of a commit message are: \* subject line: a short
description of the commit, maximum 50 characters long \* body
(optional): a longer description of the commit, wrapped at 72
characters, separated from the subject line by a blank line

You are free to structure commit messages; however, git commands like
`git log` utilize above structure. Therefore, it can be helpful to
follow a convention within your team and to utilize git best.

For example, [Conventional
Commits](https://www.conventionalcommits.org/) is a lightweight
convention that complements [SemVer](https://semver.org/), by describing
the features, fixes, and breaking changes made in commit messages. See
[Component Versioning](../component-versioning/) for more information on
versioning.

For more information on commit message conventions, see:

-   [A Note About Git Commit
    Messages](https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html)
-   [Conventional Commits](https://www.conventionalcommits.org)
-   [Git commit best
    practices](https://medium.com/@nawarpianist/git-commit-best-practices-dab8d722de99)
-   [How to Write a Git Commit Message](https://cbea.ms/git-commit)
-   [How to Write Better Git Commit
    Messages](https://www.freecodecamp.org/news/how-to-write-better-git-commit-messages)
-   [Information in commit
    messages](https://wiki.openstack.org/wiki/GitCommitMessages#Information_in_commit_messages)
-   [On commit
    messages](http://who-t.blogspot.com/2009/12/on-commit-messages.html)

## Managing remotes

A local git repository can have one or more backing remote repositories.
You can list the remote repositories using `git remote` - by default,
the remote repository you cloned from will be called origin

```bash
    > git remote -v
    origin  https://github.com/microsoft/code-with-engineering-playbook.git (fetch)
    origin  https://github.com/microsoft/code-with-engineering-playbook.git (push)
```

### Working with forks

You can set multiple remotes. This is useful for example if you want to
work with a forked version of the repository. For more info on how to
set upstream remotes and syncing repositories when working with forks
see GitHub\'s [Working with forks
documentation](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/working-with-forks).

### Updating the remote if a repository changes names

If the repository is changed in some way, for example a name change, or
if you want to switch between HTTPS and SSH you need to update the
remote

```bash
    # list the existing remotes
    > git remote -v
    origin  https://hostname/username/repository-name.git (fetch)
    origin  https://hostname/username/repository-name.git (push)

    # change the remote url
    git remote set-url origin https://hostname/username/new-repository-name.git

    # verify that the remote URL has changed
    > git remote -v
    origin  https://hostname/username/new-repository-name.git (fetch)
    origin  https://hostname/username/new-repository-name.git (push)
```

### Working with submodules

Submodules can be useful in more complex deployment and/or development scenarios where you wish to track changes to a repository that you do not own, and incorporate those changes into your own codebase.

Adding a submodule to your repo:

```bash
git submodule add <link_to_repository>
```

NOTE: A submodule will create a repository inside of your repository -- this means that there are two separate places to track changes and make commits.

## Rolling back changes

Before a set of commits are pushed to a shared repository, they can be modified directly. This is a very useful tool for preparing a pull request -- we can erase the commits that we have made previously and "request to pull" a brand new set of commits where necessary.

Whenever you have a code review that requests you fix things like commit messages/titles, or requests that you split an existing commit into smaller chunks, you will **need to reset or rebase those commits, recover the changes, and create new commits**. This is not so difficult, once you are used to it -- the two main commands you will need are `git rebase` and `git reset`. See below for more details:

### Reverting and deleting commits

To \"undo\" a commit, run the following two commands: `git revert` and
`git reset`. `git revert` creates a new commit that undoes commits while
`git reset` allows deleting commits entirely from the commit history.

To **delete** the latest commit use `HEAD~`:

```bash
    git reset --hard HEAD~1
```

To delete commits back to a specific commit, use the respective commit
id:

```bash
    git reset --hard <sha1-commit-id>
```

Interactive rebase for undoing commits:

```bash
    git rebase -i HEAD~N
```

The above command will open an interactive session in an editor with the last N commits sorted from oldest to newest. To undo a commit, delete the corresponding line of the commit and save the file. Git will rewrite the commits in the order listed in the file and because one (or many) commits were deleted, the commit will no longer be part of the history.



