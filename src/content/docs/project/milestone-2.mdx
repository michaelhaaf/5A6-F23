---
title: "Milestone 2: Project Proposal and Dev Environment"
description: "We will begin the semester project by familiarizing ourselves with how Kotlin applications are built and deployed for Android applications. In this milestone, you will build on GitHub skills learned last semester to automatically build and version a basic Android application."
tableOfContents:
  minHeadingLevel: 2
  maxHeadingLevel: 4
sidebar:
  hidden: false
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

<div class="first-col-header">
| | |
| --- | --- |
| Worth: | 10% |
| Due: | Sprint 1 (3%): **Oct 6** | 
| | Sprint 2 (7%): **Oct 20** |
| Hand-in: | A link to your group GitHub repository handed in on Moodle, as well as slides for your presentation. See [Requirements](#requirements) for more information. |
| Notes: | Late submissions will not be accepted for either part of this milestone | 
</div>

The course project will see your groups collectively scope, define, implement, and deliver a complete Android application over the course of the semester. 

This milestone has two parts: 

> **Sprint 1** (3%, Oct 6): Set up a group repository for developing and releasing Android software
> 
> **Sprint 2** (7%, Oct 20): Write a technical proposal presenting your Android project.

This repository and proposal will be the foundation of the rest of your project -- you will continue to use and update both as your project develops throughout the semester, and along the way, learn and practise important application development and delivery best practises.

## Goals

The goal of this milestone isn't to craft a perfect plan that fortells exactly what your app will become from the outset. Rather, this milestone is about setting your team on the **best footing possible** for **accomodating changing requirements** and **collaborating on a polished final project** as you create your application and make continuous progress throughout the semester.

By the end of this milestone, you will have done the following:

  - **Sprint 1:** Apply repository management practises to maintain throughout the semester:
    - **Use branch management techniques** to *separate developer efforts* and *separate requirement tasks*
    - **Enforce pull requests to main branch** to enforce clean, linear history *(continuous integration)*
    - **Use Android linting/building tools** to enforce each release proven to meet defined build requirements *(continuous depoyment)*
    - **Create releases** from passing, approved and reviewed pull requests pushes to main *(semantic versioning)*
  - **Sprint 2:** Propose and scope your project:
    - Determine what exactly your project is for and what it will be *(requirements analysis)*.
    - Determine what features to implement, publish a road map for implementing them, and plan for contingencies and how they interact *(risk analysis)*.
    - **Document and present the above in a technical presentation**. 

## Requirements

This milestone kicks off your project by having you complete two discrete tasks. Instructions and specific requirements are given in the sections below.

  - **(Oct 6)** Create a group repository to track contributions, store documentation, and marshal required project infrastructure for automated CI/CD throughout the semester
  - **(Oct 20)** Prepare a proposal presentation explaining the major goals of the project, the technical roadmap for attaining those goals, and associated risk analysis/mitigation strategies.

### (Oct 6) Repository, CI/CD

This milestone starts things off by having you set up an automated development environment on GitHub -- we will build on this repository as the semester progresses with more sophisticated features.

The basic development environment requirements for Milestone 2 build on skills you learned last semester: 

- Create a repository shared amongst your teammembers 
- Enforce and maintain a clean repository history with your teammembers
- Write a GitHub actions workflow file to automate compiling and building your project source code
- Implement and release an initial landing page for your application to prove that your repository infrastructure works.

Marks for this sprint are determined by meeting the above requirements, defined in the sections below.

#### Repository & README

The first step is to create a github repository. I've created a GitHub **repository template** for you to use: [Link to template repository](https://github.com/michaelhaaf/5A6-F23-project-template).


- Click **Use this template** in the top right corner of the project template screen. (linked in the paragraph above.) Then fill out the following information:
- **Repository name**: Either the *name of your application* (if you have one decided), or *5A6-group-project*, or something else similarly descriptive of your project.
- Make the repository **private**.
  - After making the repository, **add yourself your team members and myself (michaelhaaf) as collaborators** to this project.
  - To be clear, you will have just **one** shared repository in the group.

#### README

Project READMEs are the most visible public information about your project. They introduce the purpose of the project, how it is used, and how it is developed. You can read more about the purpose of READMEs in the [GitHub Docs](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-readmes).

In [GitHub, project READMEs support Markdown](https://docs.github.com/en/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax) which allows you to use images and advanced formatting such as links, lists, and headers -- that way, your README can be quite expressive.

Your README can and will be updated throughout the semester. **By the Sprint 1 deadline**, it should adhere to the following template and the content should be written:

```markdown title="README.md"
# PROJECT NAME

## Goal
A brief description of your application. Should answer, as concisely as you can: what is it? what is its purpose?

## Quick-start
How to install and launch your application. These should include instructions for:
- (by Sprint 1) building and running your release from source code (i.e. your github repo)

## Screenshots of application
- (by Sprint 1): Screenshots from each of the main screens of your application.

## Team members
List each person's name and email address.
```

#### Enforce branch management

Once the repository is created:

- Create a [branch protection rule](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/managing-a-branch-protection-rule) for the default `main` branch. Read through the document linked and make sure you understand all of the options listed.

**Ensure that the following branch protection rules are enabled:**
  - "Require deployments to succeed before merging". We will set up a deployment environment later.
  - "Require status checks to pass before merging". We will set up status checks later.
  - "Require pull request reviews before merging"
  - "Require linear history" 
  - **"Do not allow bypassing the above settings"** This setting is important, since the creator of the repository will, by-default, bypass the above settings. We want to prevent accidental merges to main.

These steps will allow all group members to freely develop on their own branches, test deployments on their own branches, and then REQUIRE that merges to the main branch are reviewed by team members and pass the CI/CD pipeline steps.

#### Developer workflow

Once the above rules are enforced, *you will no longer be able to directly push your commits to the repository from `main` branch*. Instead, you will create branches as needed, and when the work on those branches is complete, you will create **pull requests** -- that is, a request to pull your changes from one branch to the `main` branch.

How does this work? It does depend on the tools you use. Here are some examples:

<Tabs>
  <TabItem label="Command Line">
    1. Create a new branch (named myname-dev) within a repository

    ```bash
    git switch -c myname-dev   
    ```

    2. Make code changes

    3. Verify your code changes (before staging your changes)

    ```bash
    # 'git status' may be the git command I use most
    # provides an overview of the repository at current moment in time
    git status

    # by default, `git diff` shows the line-by-line additions/removals/changes to all unstaged changes in your repository
    git diff
    ```

    4. Stage your code changes

    ```bash

    # Use `git add` to "stage" (prepare) your changes for committing
    git add <filenamePattern>

    # E.g.: '.' to stage all changes in the repo
    git add .

    # E.g.: 'app' to stage all changes in the app/ directory
    git add app

    # E.g.: '*.md' to stage all changes to markdown files in the root directory
    git add *.md
    ```

    5. Verify your code changes (after staging)
    ```bash
    # Remember how I was saying `git status` is the most common command I use?
    # After every git operation, a `git status` command will show what has taken place.
    git status

    # The --staged argument shows only the line-by-line differences that have been staged for committing.
    git diff --staged
    ```
    6. Create a commit from staged changed

    ```bash
    # Changes that can be summarized in a single sentence:
    git commit -m "Inline commit message"

    # Changes that require further detail (opens your default text editor)
    git commit
    ```

    7.  Verify your code changes (after committing)

    ```bash
      git diff HEAD~1 
      git diff HEAD~n 
      git log
    ```

    8. Push your changes

    ```bash
    # Create a branch on the remote repository with the same name as your local repository
    git push origin myname-dev 

    # NOTE: you will need to read the output from git to follow subsequent steps for making this command work.
    ```

  </TabItem>
  <TabItem label="Android Studio GUI">

    More detail coming soon. For now: [this link starting from step 4 is very useful](https://code.tutsplus.com/working-with-git-in-android-studio--cms-30514t)

  </TabItem>
  <TabItem label="GitHub GUI">
  
    More detail coming soon. For now, [this link is very useful](https://docs.github.com/en/desktop/making-changes-in-a-branch/pushing-changes-to-github-from-github-desktop)

  </TabItem>
</Tabs>

:::tip
Why make **pull requests** instead of **pushes** to a shared repository? Once the repository is shared with more than once person, the code in it no longer belongs to a single developer. It is easy to accidentally push to a branch you own -- when it is your own branch, that is no problem, but when the branch is shared, that can introduce bugs and overwrite the work of colleagues.
:::



#### Commit quality

One of the main positive outcomes of managing branch history intentionally is producing **readable and maintainable code history**. You can read more detailed about that in [future lecture notes].

For now, please follow the [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) commit message format -- not only does this format follow good practises, but it will also leave the door open for us to automate git history analysis usince tools compatible with Conventional Commit format.

You can also read more here: [recommended article on git commit meesages](https://www.theodinproject.com/lessons/foundations-commit-messages), which links to [another recommended article](https://cbea.ms/git-commit/) on git.

Your grade for this section will be determined based on the following criteria:
- commit message and content quality
- branches used appropriately
- all pull requests to main are reviewed by team members, pass basic build tests, and use automatic versioning

#### GitHub Workflows

As mentioned in the previous section, the expectation for this project is that your **main** branch maintains a linear history while contributions are made by all project members, and that **each commit in the main branch corresponds to valid release of your project that can be built and compiled**, allowing your project to support rollbacks and version pinning.

You might wonder -- with such strict requirements about your main branch and CI/CD, what happens if you accidentally push code to main that does not build?

The answer: we are building repositories that do not allow you to do this. See the [enforce branch management](#enforce-branch-management) requirements above.

Some of the branch management abilities we enabled allow us to enforce certain building steps, or test results have taken place before accepting the pull request.

We'll use these abilities to define **two distinct GitHub workflows** that you can improve upon throughout the semester:

**Workflow Requirements**:

1. (Sprint 1) A **pull request** workflow that **lints** Kotlin and Android code for style -- this **pull request** workflow should be incorporated in every pull request. 
2. (Sprint 1) A **release** workflow that ensures Gradle can build your source code and create . The **release** workflow should **trigger** AFTER a pull request from `main` has been accepted.

You will find the following resources helpful in this task:
- [Android GitHub Actions Setup](https://medium.com/coletiv-stories/android-github-actions-setup-21ba37cf5a4f)
- [Github Actions and Gradle](https://docs.gradle.org/current/userguide/github-actions.html)
- [Workflow file syntax](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)
- Useful articles: [Choosing the right JDK](https://developer.android.com/build/jdks), [Understanding Android build system](https://developer.android.com/build)
- Installing [ktlint](https://github.com/pinterest/ktlint): it's recommended you use the ktlint plugin available from the mavenCentral repository -- meaning, let Gradle automatically find and install ktlint for you, per-project. See [simple-setup](https://github.com/jlleitschuh/ktlint-gradle#simple-setup) for instructions.
  - Using ktlint in your project gradle: [sample build.gradle.kts](https://github.com/JLLeitschuh/ktlint-gradle/blob/main/samples/kotlin-ks/build.gradle.kts)

Your grade will be based on having **two**- working github workflows: appropriate JDK, SDK, Gradle, and other configurations for both the **pull request** and **release** workflows.

#### Initial implementation and release

This part of the milestone should be the easiest -- you are welcome (in fact, encouraged) to adapt code from [Assignment 2][a2] work for your initial landing page.

The requirements for this follow:

- Your code passes the Grade Build defined in your GitHub Actions (you should NOT accept a pull request that fails this build!)
- One different "screens" per developer on the project (2 or 3). The requirements for these are loose, but should be something you actually anticipate being a part of your project; some suggestions:
  - a landing page
  - a help page
  - a contact page
  - etc.


##### Release

When your initial implementation is ready (i.e., all 2 or 3 screens have been reviewed and merged into main), you will **published your first release of the application**.

The following information will be helpful for this task:

- [GitHub Releases](https://docs.github.com/en/repositories/releasing-projects-on-github/about-releases)
- [git tags](https://git-scm.com/book/en/v2/Git-Basics-Tagging)

For the version number, choose **v0.1.0**. Subsequent releases should be defined as follows (from [semvar.org](https://semver.org/)):
> Given a version number MAJOR.MINOR.PATCH, increment the:
> 
>   - MAJOR version when you make incompatible API changes
>   - MINOR version when you add functionality in a backward compatible manner
>   - PATCH version when you make backward compatible bug fixes
> 
> Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.

### (Oct 20) Project Design & Risk Analysis

#### Design Proposal

For this part of the milestone, you will **prepare a presentation for the rest of class** introducing your application idea and your plan for implementing it over the course of the semester. 

Your presentation should be shareable as a **PDF** and should cover the following topics in less than ~15 minutes:

**Part A:** Determine and document the requirements for the business logic of your web application for the group project.
  - **Introduction and Motivation:** Give the motivations for your project -- what inspired it and what you hope to achieve. This should be in-line with the [README](#) you created in the previous part of the milestone.
    - e.g., what kind of problem are you trying to solve, what kind of capability to you want to provide the user, what kind of experience do you want to give the user.
  - **Business Logic Requirements:** identify your data needs, user interface requirements, key required operations and any data dependencies. Highlight any validity constraints on data, user interface, and operations. Describe any "rules" that will apply:
    - e.g., all entries must have a name and title, but optionally an image
    - e.g., all users must have a profile indicating their name, age and seating preference
    - e.g., all spells must have a type, title and area of effect, but may belong to multiple schools
    - e.g. all artist names must be unique; no two items may be placed in the same location
    - etc.

Note: This is not a set of "features". This is a description of your **acceptance critera**, that is, what your application needs to be able to do in order to be considered a success.

**Part B:** Design and document a coherent, consistent application that will meet those business logic requirements as well as the technical, functional and soft requirements of the project.
  - **Interface Design:** Describe the inspiration for your interface design. Provide detailed mock-ups of the interface, sufficient to identify the aesthetics and key functionality. This section should clearly inform front-end development.
    - A mock-up should be given for each key feature.
    - Mockups may be created with computer software or hand-drawn.
  - **Application Features:** Describe the features of the application. A feature should be discussed in terms of the UI elements, user actions, the
back-end functionality and the requirement(s) it is in service of. A feature should be indicated as a "Must-Have" or as a "Nice-to-Have".
  - **Coding Techniques/technologies:** The core coding techniques and technologies that will be used should be documented. Document these even if they are largely in line with what we have done in class. If you are planning to use methods not covered in class, document them in
sufficient detail to inform development. Take a look at the [sample compose apps](https://github.com/android/compose-samples/tree/main) we saw in Milestone 1 for inspiration.

The goal of this design section is to be as comprehensive as possible in specifying what you will implement and how. But, you are allowed to adapt things as appropriate as development proceeds. E.g., a technique turns out to be too hard, a 3rd party tool doesn't meet the need the way you thought it would, you identify a new technique that could add some interesting functionality, etc.

**Part C:** Create a development plan for successfully completing the project. The plan must include a **timeline**, a **tasking plan** and a **coordination plan**

  - **Timeline:** Indicate the key milestones of the project. You will find the [course calendar][calendar] useful. Some key milestones to include in your timeline are:
    - [Milestone 3][m3]: Nov 17
    - [Milestone 4][m4]: Dec 7
    - Take into account Assignment deadlines from the calendar as well. Note: assignments 2-4 are designed to be complementary with project work -- you will be honing skills that you can re-use/adapt for your project naturally throughout the semester.
    - Most classes in late October and throughout November will be available for lab time, as we will have covered most course concepts.
    - Take into account the [Academic Calendar](https://johnabbott.qc.ca/wp-content/uploads/2023/05/DAY_Academic-Calendar_2023-2024_Final_March_2023.pdf) in your planning.

  - **Tasking plan:** Indicate, as much as possible, all the tasks involved in the project and who those tasks are assigned to. You should break tasks up into subtasks as appropriate.
    - Each task should be detailed with a short prose description at least one sentence long. More complex tasks should be given m ore detailed descriptions.
    - As much as possible, indicate any dependencies between tasks,
    - All tasks should be assigned their own anticipated deadline. This is not a hard deadline, but should reflect dependencies and should guide your team's priorities. For instance, "nice-to-Haves" should generally not be given priority over "must-haves".

  - **Coordination plan:** Indicate how your team will work together on this project, including coding coordination (e.g., git), document coordination (e.g., git, google
doc, sharepoint, etc) and communication coordination (e.g., discord, in-person meetings, etc.). 
    - The coordination plan should include a schedule of planned meetings or shared coding sessions for ensuring the team stays on track. 
    - Note: If the coordination plan does not feel like it will work for you (e.g., teammates want to work on the weekend but you have a part-time job), then this is the time to be up-front and tell them what you can commit to and what you can't (e.g., willing to stay after class twice a week to meet since you can't make weekends).

#### Risk assessment

To document risk assessment for your project requirements on GitHub, there are two important tools to learn:

- [Milestones](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/about-milestones)
- [Issues](https://docs.github.com/en/issues/tracking-your-work-with-issues/quickstart)

These are the public-facing requirement trackers for your project that are kept up to date while you maintain the project. 

The [repository template](https://github.com/michaelhaaf/5A6-F23-project-template/) I have provided you comes with two Issue types to use for writing risk assessments for each of your tickets:

- [Requirement](https://github.com/michaelhaaf/5A6-F23-project-template/blob/main/.github/ISSUE_TEMPLATE/requirement.md): used to define high-level project requirements that are broken up into tasks using **Work Breakdown Structure WBS**
- [Task](https://github.com/michaelhaaf/5A6-F23-project-template/blob/main/.github/ISSUE_TEMPLATE/task.md): used to define Requirement subtasks using **Level of Effort (LOE)** estimations

Your mark for this portion of the assessment will be determined on:
- how well you document your requirements and subtasks
- how much your requirements and substask analysis actually makes sense.

You will find the following resources helpful:

- [GitHub Task list overview](https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/about-task-lists)
- [Creating a Task List](https://docs.github.com/en/issues/managing-your-tasks-with-tasklists/creating-a-tasklist#creating-tasklists-with-markdown)

#### (Optional) Roadmap

*NOTE: this part of the project is currently optional*

Part of this milestone is to convert the goals, requirements, and risk analysis you've performed in the previous sections into a [GitHub Roadmap](https://github.com/github/roadmap). 

Roadmaps are relatively common features in open-source projects for keeping-in-the-loop your community of developers, contributers, and users of your software -- the "roadmap" project is a recent attempt by GitHub to provide a GUI for automating some of this effort.

To adapt your proposal to a GitHub roadmap, see the links below for documentation and tutorials:

- [Quickstart for GitHub Projects](https://docs.github.com/en/issues/planning-and-tracking-with-projects/learning-about-projects/quickstart-for-projects)
- [Project planning in Github using Roadmap](https://docs.github.com/en/issues/tracking-your-work-with-issues/planning-and-tracking-work-for-your-team-or-project)

You will also find the following helpful:

- [Github Project overview](https://docs.github.com/en/issues/planning-and-tracking-with-projects/learning-about-projects/about-projects)
- [Best practises for GitHub Projects](https://docs.github.com/en/issues/planning-and-tracking-with-projects/learning-about-projects/best-practices-for-projects)

## Summary

This may seem like a lot of work! In fact, we are covering quite a bit of ground but the actual effort required for each component of this milestone should be light (and you can delegate these tasks amongst your group members).

The big picture is: As the project continues beyond this milestone, you will have:
  - a plan for what features you are going to implement
  - defined acceptance requirements for considering those features completed
  - a structure to accomodate changes to those requirements and to budget time/risk associated with those changes
  - semantic versioning and releases associated with each feature implementation
  - **automated** communication of feature implementations among your contributers developers and those who can view the repository
  - **automated** history tracking so that all contributers can clearly understand the course of the development of the software, and rollback changes as required.

These efforts will make the final efforts of releasing a testable beta application [Milestone 3][m4] and a polished final release [Milestone 4][m4] that much easier and lighten you load in the later semester, allowing you to focus on code and making cool things without hassling about infrastructure, plans, and communication.

## Marking Scheme

The marks for each sprint will be assessed based on meeting the requirements outlined in each section.

**Sprint 1: Repository and CI/CD**
- 30%: README and repository setup requirements
- 30%: Repository branch management best practises
- 40%: Working GitHub Actions, initial release requirements met 

**Sprint 2: Project Design & Risk Analysis**
- 30%: Proposal 
- 30%: Risk assessment
- 30%: Presentation
- 10%: GitHub Roadmap

## Tips and Resources

### Reference

- [Gradle User Manual](https://docs.gradle.org/current/userguide/userguide.html)
- [Gradle tutorial](https://www.youtube.com/watch?v=gKPMKRnnbXU) -- step by step for "90%" of the Gradle knowledge you need to build "any Gradle project". Good conceptual overview with examples/step-by-step.
- [git documentation](https://git-scm.com/docs)
- [Creating and editing milestones](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/creating-and-editing-milestones-for-issues-and-pull-requests)
You can also see more examples (that go beyond our needs for now) here:
- [Android CI-CD using Github Actions](https://blog.logrocket.com/android-ci-cd-using-github-actions/)
- [Securely create android release using Github Actions](https://proandroiddev.com/create-android-release-using-github-actions-c052006f6b0b)



[a1]: /5A6-F23/assignments/assignment-1
[a2]: /5A6-F23/assignments/assignment-2
[a3]: /5A6-F23/assignments/assignment-3
[a4]: /5A6-F23/assignments/assignment-4
[m1]: /5A6-F23/project/milestone-1
[m2]: /5A6-F23/project/milestone-2
[m3]: /5A6-F23/project/milestone-3
[m4]: /5A6-F23/project/milestone-4
[calendar]: /5A6-F23/about/calendar

[lecture-commit-notes]: /5A6-F23/lectures/development/git
